# アーキテクチャ

## 3 層構造

- プレゼンテーション層
  - アプリケーションの利用者（人や別プログラム）とのやりとり
  - 見た目などの UI に直接関わることだけを知っているべきもの
  - 例：
    - リクエストのバリデーション
    - 見た目を整えるための処理
- ビジネスロジック層
  - アプリが従うべきルールチェック・計算処理
  - システムなしで人が同じことをするときに登場するルール
    - 処理の流れを実現すること：ユースケース、アプリケーションビジネスルール
    - システム都合ではないコアなルール：ドメインロジック、エンタープライズビジネスルール
  - UI の違いに左右されない
  - 保存先の違いに左右されない
  - 例：
    - SNS で自分にはイイネできないようにする
    - TODO 管理アプリで過去日の TODO は登録できないようにする
- データアクセス層
  - データの保存先（DB やファイル）とのやりとり
  - 例：
    - MySQL への接続処理

## ビジネスロジック

- トランザクションスクリプトパターン
  - データの入れ物と処理を分離する
  - 手続き方プログラミング
  - Service がドメインロジックとユースケースを担当
  - メリット：学習コストが低い
  - デメリット：同じロジックが Service クラス間に分散しやすく変更に弱い、肥大化しやすい
- ドメインモデルパターン（こっちがよい！）
  - データの入れ物に処理も持たせる
  - オブジェクト指向プログラミング
  - Model はドメインロジックを担当
  - Service はユースケースを担当
  - メリット：同じロジックが分散しにくく変更に強い、肥大化しにくい
  - デメリット：学習コストが高い

## データアクセス

- リポジトリパターン
  - ドメインモデルの都合でまとまった単位でデータの読み書きをする
- テーブルゲートウェイパターン
  - テーブル単位で読み書きする
